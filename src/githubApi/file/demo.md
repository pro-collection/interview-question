**关键词**：Object 与 Map

在 JavaScript 中，`Object` 和 `Map` 都可以用于存储键值对，但它们的设计目标和性能特性存在差异，选择哪一种取决于具体使用场景。

### **核心差异与性能对比**

#### 1. **内存占用**

- **`Object`**：  
  本质是原型链继承的对象，会默认一些额外属性（如 `__proto__`、`constructor`），且键只能是字符串或 Symbol。  
  对于少量键值对，内存开销较小，但键名会被强制转换为字符串（如数字 `1` 会转为 `"1"`）。

- **`Map`**：  
  专为键值对存储设计，无原型链开销，键可以是任意类型（包括对象、函数等）。  
  但内部实现会维护哈希表结构，存储相同数量的键值对时，内存占用通常比 `Object` 略高（尤其键值对较少时）。

#### 2. **读写性能**

- **`Object`**：

  - **读取/写入速度**：对于静态键（提前确定的键名），访问速度极快，因为 JavaScript 引擎会对对象属性进行优化（如静态属性的偏移量缓存）。
  - **动态键场景**：如果键名是动态生成的（如通过变量拼接），性能会略有下降（需哈希计算），但仍优于 `Map` 对非字符串键的处理。

- **`Map`**：
  - **读取/写入速度**：对于频繁的增删改查（尤其是动态键或非字符串键），性能更稳定。
  - 优势体现在：键可以是任意类型（无需转换）、内部哈希表优化更适合高频动态操作。
  - 劣势：对于静态字符串键，访问速度通常比 `Object` 慢 10%-30%（不同引擎优化不同）。

#### 3. **遍历性能**

- **`Object`**：  
  遍历需要先获取键名（`Object.keys()` 等），再迭代访问，步骤较多。  
  且会遍历自身可枚举属性（需注意原型链污染问题），额外消耗性能。

- **`Map`**：  
  原生支持迭代器（`for...of` 直接遍历），遍历速度通常比 `Object` 快，尤其是键值对数量较多时。  
  且 `Map` 的 `size` 属性可直接获取长度（`Object` 需要 `keys().length` 计算），更高效。

#### 4. **极端场景测试**

- **小规模数据（<100 键值对）**：  
  `Object` 性能略优，内存占用更低，适合简单配置、数据存储。

- **大规模数据（>1000 键值对）**：  
  `Map` 在频繁增删、动态键、遍历场景下性能更稳定，`Object` 可能因哈希冲突导致性能波动。

- **非字符串键**：  
  `Map` 优势明显（无需转换键类型），`Object` 需要手动处理键名转换（如将对象转为字符串标识），既麻烦又影响性能。

### **使用建议**

| 场景                           | 推荐选择 | 理由                                                              |
| ------------------------------ | -------- | ----------------------------------------------------------------- |
| 静态键名（如 `{ name: 'a' }`） | `Object` | 访问速度快，语法简洁，适合数据结构固定的场景（如配置、DTO）。     |
| 动态键名（如变量作为键）       | `Map`    | 无需处理键名转换，增删改查性能更稳定。                            |
| 非字符串键（对象、函数等）     | `Map`    | 原生支持任意类型键，`Object` 会强制转换键为字符串，可能导致冲突。 |
| 频繁增删或遍历                 | `Map`    | 迭代器优化更好，`size` 属性获取高效，适合缓存、集合类场景。       |
| 序列化需求（`JSON.stringify`） | `Object` | `Map` 无法直接序列化，需手动转换为对象，`Object` 原生支持。       |

### **总结**

- **`Object`** 适合静态、简单的键值对存储，语法简洁，内存占用低，静态访问速度快。
- **`Map`** 适合动态、复杂的键值对场景（尤其是非字符串键、高频增删遍历），性能更稳定。

性能差异在大多数业务场景中不明显，优先根据代码可读性和功能需求选择，极端性能敏感场景（如大数据处理）再针对性优化。
